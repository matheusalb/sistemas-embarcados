C51 COMPILER V9.60.0.0   EXPERIMENTO6                                                      11/10/2021 00:58:35 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE EXPERIMENTO6
OBJECT MODULE PLACED IN .\Objects\Experimento6.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Experimento6.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\Experimento6.lst) TABS(2) OBJECT(.\Objects\Experimento6.obj)

line level    source

   1          // Aluno: Matheus Viana Coelho Albuquerque
   2          
   3          #include <REG517A.H>
   4          
   5          #define TAMANHO_BUFFER 16
   6          #define TH1_RECARGA 204
   7          
   8          // Estrutura para representar o buffer circular
   9          typedef struct {
  10            char buffer[TAMANHO_BUFFER];
  11            unsigned char in;
  12            unsigned char out;
  13          }CircularBuffer;
  14          
  15          CircularBuffer TxBuffer;
  16          CircularBuffer RxBuffer;
  17          bit RecebeuString = 0;
  18          bit txOcupado = 0;
  19          
  20          void SendChar(char c) {
  21   1        /*Função que recebe o byte “c” e insere em TxBuffer.
  22   1        Ativa a transmissão serial, caso ainda não esteja Ativa.*/
  23   1        
  24   1        // Para inserir o byte em TxBuffer preciso saber se ele não está cheio
  25   1        if (((TxBuffer.in + 1)%TAMANHO_BUFFER) != TxBuffer.out) {
  26   2          // Caso o TxBuffer não esteja cheio
  27   2          // Insiro no buffer
  28   2          TxBuffer.buffer[TxBuffer.in] = c;
  29   2          // Incremento o TxBufferIn
  30   2          TxBuffer.in = (TxBuffer.in + 1)%TAMANHO_BUFFER;
  31   2        }
  32   1        
  33   1        // Verifica se o TxBuffer está ocupado transmitindo informação para a interface serial
  34   1        if (!txOcupado) {
  35   2          // Caso não esteja ocupado, ocupo-o e ativo a transmissão serial
  36   2          txOcupado = 1;
  37   2          TI0 = 1;
  38   2        }
  39   1          
  40   1      }
  41          
  42          void SendString(char *s) {
  43   1        //Função que insere a string apontada por “*s” em TxBuffer usando a função SendChar(c).
  44   1        
  45   1        int i = 0;
  46   1        char curCharacter;
  47   1        // Loop que envia os caracteres da string para TxBuffer por meio de SendChar
  48   1        do{
  49   2          curCharacter = s[i];
  50   2          SendChar(curCharacter);
  51   2          i++;
  52   2        }while(curCharacter != '$');
  53   1      }
  54          
C51 COMPILER V9.60.0.0   EXPERIMENTO6                                                      11/10/2021 00:58:35 PAGE 2   

  55          char RxBufferVazio() {
  56   1        // Função que retorna 1 caso o buffer circular de recepção esteja vazio e 0 em caso contrário.
  57   1        char vazio = 0;
  58   1        if (RxBuffer.in == RxBuffer.out)
  59   1          vazio = 1;
  60   1        return vazio;
  61   1      }
  62          
  63          char TxBufferVazio() {
  64   1        // Função que retorna 1 caso o buffer circular de transmissao esteja vazio e 0 em caso contrário.
  65   1        char vazio = 0;
  66   1        if (TxBuffer.in == TxBuffer.out)
  67   1          vazio = 1;
  68   1        return vazio;
  69   1      }
  70          
  71          char ReceiveChar() {
  72   1        // Função que retorna um byte de RxBuffer
  73   1        
  74   1        char character = 0;
  75   1        // Verifico se o RxBuffer não está vazio para retornar um caracter
  76   1        if (!RxBufferVazio()) {
  77   2          character = RxBuffer.buffer[RxBuffer.out];
  78   2          RxBuffer.out = (RxBuffer.out + 1)%TAMANHO_BUFFER; 
  79   2        }
  80   1        return character;
  81   1      }
  82          
  83          
  84          void ReceiveString(char *s) {
  85   1        // Função que copia uma string de RxBuffer para o local apontado por “*s”, usando a função ReceiveChar().
  86   1        char character;
  87   1        int i = 0;
  88   1        do {
  89   2          // Loop para ler o caracter do RxBuffer e adiconar a string, termina quando encontra o $ indicando o fin
             -al da string
  90   2          character = ReceiveChar();
  91   2          s[i] = character;
  92   2          i++;
  93   2        } while(character != '$' && !RxBufferVazio());
  94   1        
  95   1        RecebeuString = 0;
  96   1      } 
  97          
  98          void baudrate_inicializa() {
  99   1        
 100   1        ADCON0 = ADCON0 | 0x80; // Faço BD = 1 para ativar o baud rate
 101   1      }
 102          
 103          void serial_inicializa() {
 104   1        S0CON = (S0CON & 0x0F) | 0x50; // Faz SM0 = 0 SM1 = 1 => ativa modo 1; SM20 = 0; REN0 = 1
 105   1        PCON = PCON | 0x80; // Ativo o bit mais significativo de PCON, basicamente SMOD = 1
 106   1      }
 107          
 108          void comunicacaoserial() interrupt 4 using 2 {
 109   1        char c;
 110   1        // Verifico tanto transmissao quanto recepção pois é full-duplex
 111   1        if (TI0) {
 112   2          TI0 = 0; // Zero o TI0 pois não é feito automaticamente
 113   2          
 114   2          if (!TxBufferVazio()) {
 115   3            // Se o tx não estiver vazio leio um caracter do TxBuffer e o envio pelo barramento serial
C51 COMPILER V9.60.0.0   EXPERIMENTO6                                                      11/10/2021 00:58:35 PAGE 3   

 116   3            c = TxBuffer.buffer[TxBuffer.out];
 117   3            TxBuffer.out = (TxBuffer.out + 1)%TAMANHO_BUFFER;
 118   3            S0BUF = c;
 119   3          }
 120   2          else 
 121   2            // Caso Tx tenha sido esvaziado, desocupo-o.
 122   2            txOcupado = 0;      
 123   2        }
 124   1        
 125   1        if (RI0) {
 126   2          RI0 = 0; // Zero o RI0 pois não é feito automaticamente
 127   2          
 128   2          c = S0BUF; // salvo o caracter lido em uma variavel auxiliar
 129   2          // Verifico se o RxBuffer não está cheio para inserir o caracter nele
 130   2          if (((RxBuffer.in + 1)%TAMANHO_BUFFER) != RxBuffer.out) {
 131   3            // Caso o RxBuffer não esteja cheio
 132   3            // Insiro no buffer
 133   3            RxBuffer.buffer[RxBuffer.in] = c;
 134   3            // Incremento o TxBufferIn
 135   3            RxBuffer.in = (RxBuffer.in + 1)%TAMANHO_BUFFER;
 136   3          }
 137   2          if (c == '$')
 138   2              RecebeuString = 1;
 139   2        }
 140   1      }
 141          
 142          void initCircularBuffer() {
 143   1        TxBuffer.in = 0;
 144   1        TxBuffer.out = 0;
 145   1        RxBuffer.in = 0;
 146   1        RxBuffer.out = 0;
 147   1      }
 148          
 149          void main() {
 150   1        char s[TAMANHO_BUFFER+1];
 151   1        EAL = 1;  // Enable all interrupts
 152   1        ES0 = 1;  // Enable the serial channel 0 interrupts
 153   1        initCircularBuffer();
 154   1        baudrate_inicializa();
 155   1        serial_inicializa();
 156   1        
 157   1        while(1) {
 158   2          // Verifico se chegou uma string para enviá-la para interface serial
 159   2          if (RecebeuString) {
 160   3            ReceiveString(s);
 161   3            SendString(s);
 162   3          }
 163   2        }
 164   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    294    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     36      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
